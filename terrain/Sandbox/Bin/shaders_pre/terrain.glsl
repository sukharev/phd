/**
 * Precomputed Atmospheric Scattering
 * Copyright (c) 2008 INRIA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Author: Eric Bruneton
 */

#define FIX

const float ISun = 100.0;

uniform vec3 c;
uniform vec3 s; //sun position
uniform mat4 projInverse;
uniform mat4 viewInverse;
uniform float exposure;
//uniform sampler2D reflectanceSampler;//ground reflectance texture
//uniform sampler2D irradianceSampler;//precomputed skylight irradiance (E table)
//uniform sampler3D inscatterSampler;//precomputed inscattered light (S table)

uniform float g_uMin; 
uniform float g_vMin; 
uniform float g_sizeBlock; 

varying vec2 coords;
varying vec3 ray;

float PI_OVER_360 = M_PI / 360.;
#ifdef _VERTEX_


/*
void main() {
    coords = gl_Vertex.xy * 0.5 + 0.5;
    //vec4 coords4 = vec4(gl_Vertex.xy,1.0,1.0);
    //vec3 coords4 = vec4(coords.x,coords.y,1.0,1.0);
    ray = (viewInverse * vec4((projInverse * gl_Vertex).xyz, 0.0)).xyz;
    //ray = (viewInverse * vec4((gl_Vertex).xyz, 0.0)).xyz;
    gl_Position = gl_Vertex;
}
*/

const float g_lowFrequencyHeight = 3.25f; 
const float g_highFrequencyHeight = 0.75f; 
const float g_lowFrequencyScale = 400.0f; 
const float g_highFrequencyScale = 2500.0f; 

// input - number in range [-1,1]
// outpu - number in range [0,1]
float shift(float n){
	return (n + 1.0)/2.0;
}
// input - posUnitSphere: position on the unit sphere 
// output: elevation value generated by fractal sum 
// of high and low frequency Perlin noise 
float getElevation(in float3 posUnitSphere) { 
	float noiseHeight = 0; 
	// low frequency noise 
	float n = snoise(posUnitSphere * g_lowFrequencyScale); 
	n = shift(n); noiseHeight += n * g_lowFrequencyHeight; 
	// high frequency noise 
	n = snoise(posUnitSphere * g_highFrequencyScale); 
	n = shift(n); 
	noiseHeight += n * g_highFrequencyHeight; 
	return noiseHeight; 
}


// input - posBlock: position within the local coordinate system of the block 
// output - return value: position after transformation to uvw space 
vec3 getUVW(vec3 posBlock) { 
	vec3 posUVW; 
	posUVW.x = posBlock.x * g_sizeBlock + g_uMin; 
	posUVW.y = 0.0; 
	posUVW.z = posBlock.z * g_sizeBlock + g_vMin; 
	return posUVW; 
} 


// input - posBlock: position within the vertex buffer of the block 
// output - posS: position of south neighbor in world space 
// output - posN: position of north neighbor in world space 
// output - posW: position of west neighbor in world space 
// output - posE: position of east neighbor in world space 
void GetNeighborPos(vec3 posBlock, out vec3 posS, out vec3 posN, out vec3 posW, out vec3 posE) { 
	float g_vertexDistance = 1.0 / (g_sizeBlock + 1.0 ); 
	posS = getUVW(posBlock - vec3(0.0, 0.0, g_vertexDistance)); 
	posN = getUVW(posBlock + vec3(0.0, 0.0, g_vertexDistance)); 
	posW = getUVW(posBlock - vec3(g_vertexDistance, 0.0, 0.0)); 
	posE = getUVW(posBlock + vec3(g_vertexDistance, 0.0, 0.0)); 
	posS = normalize(mul( vec4(posS, 1.0), g_cube ).xyz); 
	posN = normalize(mul( vec4(posN, 1.0), g_cube ).xyz); 
	posW = normalize(mul( vec4(posW, 1.0), g_cube ).xyz); 
	posE = normalize(mul( vec4(posE, 1.0), g_cube ).xyz); 
	posS *= Rg + getElevation(posS); 
	posN *= Rg + getElevation(posN); 
	posW *= Rg + getElevation(posW); 
	posE *= Rg + getElevation(posE);
}

varying out vec4 posH; // SV_POSITION; 
varying out vec3 posW; // POSITION; 
varying out vec3 tangent; // TANGENT0; 
varying out vec3 bitangent; // TANGENT1; 
varying out vec2 texC; // TEXCOORD0; 

// vertex shader 
void main() { 

    //coords = gl_Vertex.xy * 0.5 + 0.5;
    //ray = (viewInverse * vec4((projInverse * gl_Vertex).xyz, 0.0)).xyz;
    //gl_Position = gl_Vertex;

	// transform position to uvw space 
	vec3 posUVW = getUVW(gl_Vertex.xyz); 
	/*
	// transform to cube and normalize to obtain position on unit sphere 
	vec3 posCube = mul(vec4(posUVW, 1.0), g_cube).xyz; 
	vec3 posUnitSphere = normalize(posCube); 
	// extrude by planetary radius and an elevation factor to obtain 
	// position in world space 
	float elevation = getElevation(posUnitSphere) * gl_Vertex.y; 
	vec3 posWorld = posUnitSphere * (g_Rg + elevation); 
	// obtain tangents vec3 neighborS, neighborN, neighborW, neighborE; 
	GetNeighborPos(gl_Vertex.xyz, neighborS, neighborN, neighborW, neighborE); 
	output.tangent = normalize(neighborW - neighborE); 
	output.bitangent = normalize(neighborS - neighborN);
	// output 
	texC = posUVW.xz; 
	posW = posWorld; 
	posH = (viewInverse * vec4((projInverse * vec4(posWorld, 1.0)).xyz, 0.0)).xyz; //mul(vec4(posWorld, 1.0), g_viewProj); 
	posH.z = output.posH.z * output.posH.w * g_invFarPlane; 
	*/
}


#else


// direct sun light for ray x+tv, when sun in direction s (=L0)
vec3 sunColor(vec3 x, float t, vec3 v, vec3 s, float r, float mu) {
    if (t > 0.0) {
        return vec3(0.0);
    } else {
        vec3 transmittance = r <= Rt ? transmittanceWithShadow(r, mu) : vec3(1.0); // T(x,xo)
        //float isun = step(cos( M_PI / 180.0), dot(v, s)) * ISun; // Lsun
        float sun_size = 4.0;
        float isun = step(cos(sun_size* M_PI / 180.0), dot(v, s)) * ISun; // Lsun
        return transmittance * isun; // Eq (9)
    }
}

vec3 HDR(vec3 L) {
    L = L * exposure;
    L.r = L.r < 1.413 ? pow(L.r * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.r);
    L.g = L.g < 1.413 ? pow(L.g * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.g);
    L.b = L.b < 1.413 ? pow(L.b * 0.38317, 1.0 / 2.2) : 1.0 - exp(-L.b);
    return L;
}

void main() {

    vec3 x = c;
    vec3 v = normalize(ray);

    float r = length(x);
    float mu = dot(x, v) / r;
    float t = -r * mu - sqrt(r * r * (mu * mu - 1.0) + Rg * Rg);

    //vec3 attenuation;
	//vec3 inscatterColor = inscatter(x, t, v, s, r, mu, attenuation); //S[L]-T(x,xs)S[l]|xs
	vec3 inscatterColor = vec3(1.0,0.0,0.0);
    vec3 groundColor = vec3(0.0);
    //vec3 groundColor = groundColor(x, t, v, s, r, mu, attenuation); //R[L0]+R[L*]
    //vec3 sunColor = vec3(0.0);
    vec3 sunColor = sunColor(x, t, v, s, r, mu); //L0
    //gl_FragColor = vec4(HDR(sunColor + groundColor + inscatterColor), 1.0); // Eq (16)
    gl_FragColor = vec4(sunColor + vec3(1.0,0.0,0.0), 1.0);
}

#endif
